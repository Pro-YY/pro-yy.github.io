<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Brooke's Notes]]></title>
  <link href="https://www.yangyang.cloud/blog/categories/linux/atom.xml" rel="self"/>
  <link href="https://www.yangyang.cloud/"/>
  <updated>2020-01-16T10:26:36+08:00</updated>
  <id>https://www.yangyang.cloud/</id>
  <author>
    <name><![CDATA[BrookeYang(杨阳)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux Seccomp Filters]]></title>
    <link href="https://www.yangyang.cloud/blog/2019/12/12/linux-seccomp-filters/"/>
    <updated>2019-12-12T22:20:45+08:00</updated>
    <id>https://www.yangyang.cloud/blog/2019/12/12/linux-seccomp-filters</id>
    <content type="html"><![CDATA[<h2>Overview</h2>

<p>Seccomp (short for Secure Computing mode) is a computer security facility in the Linux kernel. It was merged into the Linux kernel mainline in kernel version 2.6.12, which was released on March 8, 2005. Seccomp allows a process to make a one-way transition into a &ldquo;secure&rdquo; state in which it cannot make some system calls. If it attempts, the kernel will terminate the process tith SIGSYS. Seccomp-BPF was released in 2012, providing more syscall filtering features on bpf. It is used in many sandbox-like applications (i.e. Chrome/Chromium, Firefox, Docker, QEMU, Android, Systemd, OpenSSH&hellip;) for resource isolation purposes.</p>

<h2>Basic example</h2>

<p>Question: How to block specified syscalls?</p>

<p>First off, we need header files to use libseccomp2. Get the package installed:
<code>
apt install libseccomp-dev
</code></p>

<p>The following code (function <em>filter_syscalls()</em>) shows how we use seccomp in common. It filters the <code>fchmodat</code> and <code>symlinkat</code> syscalls. And also blocks <code>write</code> syscall, if the write count argument exceeds 2048.</p>

<pre><code>// ... other headers and macros ommited
#include &lt;seccomp.h&gt;

int filter_syscalls() {
    int ret = -1;
    scmp_filter_ctx ctx;

    log_debug("filtering syscalls...");
    ctx = seccomp_init(SCMP_ACT_ALLOW);
    if (!ctx) { log_error("error seccomp ctx init"); return ret; }

    // prohibits specified syscall
    ret = seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(fchmodat), 0);
    if (ret &lt; 0) { log_error("error seccomp rule add: fchmodat"); goto out; }

    ret = seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(symlinkat), 0);
    if (ret &lt; 0) { log_error("error seccomp rule add: symlinkat"); goto out; }

    // limit syscall arguments
    ret = seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 1,
            SCMP_A2_64(SCMP_CMP_GT, 2048));
    if (ret &lt; 0) { log_error("error seccomp rule add: write"); goto out; }

    ret = seccomp_load(ctx);
    if (ret &lt; 0) { log_error("error seccomp load"); goto out; }

out:
    seccomp_release(ctx);
    if (ret != 0) return -1;

    return 0;
}

extern char **environ;

int main(int argc, char *argv[]) {
    int ret = -1;

    ret = filter_syscalls();
    if (ret != 0) { log_error("filter syscall failed"); return EXIT_FAILURE; }

    char *prog = "/bin/bash";
    ret = execve(prog, (char *[]){prog, 0}, environ);
    log_debug("%d", ret);
    if (ret &lt; 0) { log_error("exec failed"); return EXIT_FAILURE; }

    return EXIT_SUCCESS;
}
</code></pre>

<p>For all source code &amp; detail, check <a href="https://github.com/Pro-YY/seccomp-demo">here</a>.</p>

<p>Note: compile the above with <code>-lseccomp</code> flags, and run it when we get our secured shell.</p>

<p>Then, try it with the execed bash prompt:
```
brooke@VM-250-12-ubuntu:~/seccomp_demo$ gcc seccomp_basic.c -l seccomp &amp;&amp; ./a.out
[DEBUG]seccomp_basic.c: 32: filtering syscalls&hellip;
brooke@VM-250-12-ubuntu:~/seccomp_demo$ chmod -x a.out  # test fchmodat
Bad system call (core dumped)
brooke@VM-250-12-ubuntu:~/seccomp_demo$ ln -s a.out     # test symlinkat
Bad system call (core dumped)
brooke@VM-250-12-ubuntu:~/seccomp_demo$ echo &ldquo;hello&rdquo;        # test write
hello
brooke@VM-250-12-ubuntu:~/seccomp_demo$ cat seccomp_basic.c # test write
Bad system call (core dumped)</p>

<p>brooke@VM-250-12-ubuntu:~/seccomp_demo$ cat /proc/$$/status
&hellip;
NoNewPrivs:     1       # cannot be applied to child processes with greater privileges
Seccomp:        2       # Seccomp filter mode
&hellip;</p>

<p>brooke@VM-250-12-ubuntu:~/seccomp_demo$ sudo ls
sudo: effective uid is not 0, is /usr/bin/sudo on a file system with the &lsquo;nosuid&rsquo; option set or an NFS file system without root privileges?
brooke@VM-250-12-ubuntu:~/seccomp_demo$ exit    # Don&rsquo;t forget quit bash
```
As expected, the process (subprocess) invoke filtered syscall get SIGSYS, and core-dumped.</p>

<h2>Export filter&rsquo;s bpf</h2>

<p>Underneath, seccomp performs filtering by using bpf, which we&rsquo;ll explain later. The libseccomp provide useful funcitons to generate and output the corresponding bpf as well as pfc (Pseudo Filter Code). Thus we can take a more close look.</p>

<p>For a trival case, we only filter the <code>fchmodat</code> syscall, and export bpf:
```
int filter_syscalls() {
    int ret = -1;
    scmp_filter_ctx ctx;</p>

<pre><code>log_debug("filtering syscalls...");
ctx = seccomp_init(SCMP_ACT_ALLOW);
if (!ctx) { log_error("error seccomp ctx init"); return ret; }

// prohibits specified syscall
ret = seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(fchmodat), 0);
if (ret &lt; 0) { log_error("error seccomp rule add: fchmodat"); goto out; }

ret = seccomp_load(ctx);
if (ret &lt; 0) { log_error("error seccomp load"); goto out; }


// export bpf
int bpf_fd = open("seccomp_filter.bpf", O_CREAT | O_WRONLY | O_TRUNC, 0666);
if (bpf_fd == -1) { log_error("error open"); goto out; }
ret = seccomp_export_bpf(ctx, bpf_fd);
if (ret &lt; 0) { log_error("error export"); goto out; }
close(bpf_fd);

// export pfc
int pfc_fd = open("seccomp_filter.pfc", O_CREAT | O_WRONLY | O_TRUNC, 0666);
if (pfc_fd == -1) { log_error("error open"); goto out; }
ret = seccomp_export_pfc(ctx, pfc_fd);
if (ret &lt; 0) { log_error("error export"); goto out; }
close(pfc_fd);
</code></pre>

<p>out:
    seccomp_release(ctx);
    if (ret != 0) return -1;</p>

<pre><code>return 0;
</code></pre>

<p>}
```</p>

<p>We got 2 files, bpf and pfc:
<code>
$ hd seccomp_filter.bpf     # hexdump bpf file
00000000  20 00 00 00 04 00 00 00  15 00 00 05 3e 00 00 c0  | ...........&gt;...|
00000010  20 00 00 00 00 00 00 00  35 00 00 01 00 00 00 40  | .......5......@|
00000020  15 00 00 02 ff ff ff ff  15 00 01 00 0c 01 00 00  |................|
00000030  06 00 00 00 00 00 ff 7f  06 00 00 00 00 00 00 00  |................|
00000040
</code></p>

<pre><code>$ cat seccomp_filter.pfc
#
# pseudo filter code start
#
# filter for arch x86_64 (3221225534)
if ($arch == 3221225534)
  # filter for syscall "fchmodat" (268) [priority: 65535]
    if ($syscall == 268)
        action KILL;
          # default action
            action ALLOW;
# invalid architecture action
action KILL;
#
# pseudo filter code end
#
</code></pre>

<p>It seems quite straightforward. And there&rsquo;s an awesome tool: <a href="https://github.com/david942j/seccomp-toolsj">seccomp-tools</a> which can disassembles <em>seccomp_filter.bpf</em> above:
<code>
 line  CODE  JT   JF      K
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007
 0005: 0x15 0x01 0x00 0x0000010c  if (A == fchmodat) goto 0007
 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0007: 0x06 0x00 0x00 0x00000000  return KILL
</code></p>

<h2>Seccomp-BPF</h2>

<p>Seccomp-BPF is just an extension of cBPF (classical Berkeley Packet Filter, Note: not eBPF).
The <strong>tiny</strong>  bpf program runs on a specific VM in kernel, with a rather limited registers and a more reduced instruction set.</p>

<p>BPF code definitions in <em>/usr/include/linux/filter.h</em>:
<code>
struct sock_filter {    /* Filter block */
        __u16   code;   /* Actual filter code */
        __u8    jt;     /* Jump true */
        __u8    jf;     /* Jump false */
        __u32   k;      /* Generic multiuse field */
};
</code></p>

<p>We can of course, directly apply seccomp-bpf binary code with prctl(), which wraps the <code>seccomp</code> syscall,
to gain more fine-graind control of our bpf. But in most casses, those libseccomp wrappers, like <code>seccomp_rule_add()</code> just works.
The binary code is the same as the just hexdumped file for filtering <code>fchmodat</code>.</p>

<pre><code>int filter_syscalls() {
    int ret = -1;

    log_debug("filtering syscalls with bpf...");

    struct sock_filter code[] = {
        /* op,   jt,   jf,     k    */
        {0x20, 0x00, 0x00, 0x00000004},
        {0x15, 0x00, 0x05, 0xc000003e},
        {0x20, 0x00, 0x00, 0x00000000},
        {0x35, 0x00, 0x01, 0x40000000},
        {0x15, 0x00, 0x02, 0xffffffff},
        {0x15, 0x01, 0x00, 0x0000010c}, // 268 fchmodat
        {0x06, 0x00, 0x00, 0x7fff0000},
        {0x06, 0x00, 0x00, 0x00000000},
    };

    struct sock_fprog bpf = {
        .len = ARRAY_SIZE(code),
        .filter = code,
    };

    ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
    if (ret &lt; 0) { log_error("error prctl set no new privs"); return EXIT_FAILURE; }

    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;bpf);
    if (ret &lt; 0) { log_error("error prctl set seccomp filter"); return EXIT_FAILURE; }

    return 0;
}
</code></pre>

<h2>Performance Overhead</h2>

<p>There is no such thing as a free lunch, so as the seccomp-bpf. After all,it is a hooking program, that runs each time whever and whatever a syscall invoked.
We benchmarked 3 senarios: no filter, filter that blocks 1 syscall, and filter that blocks 100 syscall (a more sophisticated bpf).
And we measured the time elpased during 10million <code>write()</code> syscall, and plotted as following:</p>

<div id="hc_test" style="min-width: 310px; height: 400px; margin: 0 auto">hc_test</div>




<script src="https://code.highcharts.com/highcharts.src.js"></script>


<script type="text/javascript">

function draw() {
Highcharts.chart('hc_test', {
    chart: {
      type: 'column'
    },

    title: {
        text: ''//
    },

    subtitle: {
        text: ''//
    },

    xAxis: {
        categories: ['without filter', '1-filter bpf', '100-filter pbf']
    },
    yAxis: {
        title: {
            text: 'time (seconds)',
        },
        max: 5,
        min: 0,
    },

    tooltip: {
        formatter: function () {
            return '<b>' + this.x + '</b><br/>' +
                this.series.name + ': ' + this.y + '<br/>';
        }
    },
plotOptions: {
        bar: {
            dataLabels: {
                enabled: true
            }
        }
    },

    series: [{
        type: 'line',
        name: '256 write real',
        data: [3.991, 4.157, 4.506]
    }, {
        type: 'line',
        name: '2048 write real',
        data: [3.959, 4.162, 4.502]
    }, {
        type: 'line',
        name: '256 write sys',
        data: [2.763, 3.011, 3.397]
    }, {
        type: 'line',
        name: '2048 write sys',
        data: [2.797, 3.059, 3.321]
    }]

});

}

draw();
</script>


<p>As it shows, the overhead is around 5%~10%, and will be even more with the larger bpf code.</p>

<h2>Summary</h2>

<p>In this post, we managed to filter syscalls  with several seccomp-related facilities, inspect the seccomp-bpf code, and understand its costs.
This would be helpful especially if you&rsquo;re implementing your sandbox-like applications that need security concerns.
Wish you enjoy hacking!</p>

<h2>References</h2>

<ul>
<li><a href="http://man7.org/linux/man-pages/man2/seccomp.2.html">Seccomp(2) Linux mannual page</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/seccomp_init.3.html">seccomp_init(3) Linux mannual page</a></li>
<li><a href="https://www.kernel.org/doc/html/v4.16/userspace-api/seccomp_filter.html">Kernel document: seccomp filter</a></li>
<li><a href="https://lwn.net/Articles/656307/">A seccomp overview</a></li>
<li><a href="http://man7.org/conf/lpc2015/limiting_kernel_attack_surface_with_seccomp-LPC_2015-Kerrisk.pdf">Using seccomp to limit the kernel attack surface</a></li>
<li><a href="https://github.com/seccomp/libseccomp">libseccomp source</a></li>
<li><a href="https://lwn.net/Articles/656307/">A seccomp overview</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Worker Pool With Eventfd]]></title>
    <link href="https://www.yangyang.cloud/blog/2018/11/09/worker-pool-with-eventfd/"/>
    <updated>2018-11-09T22:41:08+08:00</updated>
    <id>https://www.yangyang.cloud/blog/2018/11/09/worker-pool-with-eventfd</id>
    <content type="html"><![CDATA[<h2>Linux Eventfd Overview</h2>

<p>An  &ldquo;eventfd  object&rdquo; can be used as an event wait/notify mechanism by user-space applications, and by the kernel to notify user-space applications of events.
It has been added to kernel since Linux 2.6.22. And the object contains an unsigned 64-bit integer (uint64_t) counter that is maintained by the kernel. So it&rsquo;s extremely fast to access.</p>

<pre><code class="c">#include &lt;sys/eventfd.h&gt;
int eventfd(unsigned int initval, int flags);
</code></pre>

<p>That&rsquo;s all we need to create one eventfd file, after that, we can perform normal file operations (like read/write, poll and close) with it.</p>

<p>Once some user-space thread write it with value greater than 0, it will instantly be notified to user-space by kernel. Then, the first thread which read it, will reset it (zero its counter), i.e. consume the event. And all the later read will get Error (Resource Temporarily Unavailable), until it is written again (event triggered). Briefly, it transforms an event to a file descriptor that can be effectively monitored.</p>

<p>There&rsquo;re several notes of which we should take special account:</p>

<blockquote><p>Applications can use an eventfd file descriptor instead of a pipe <strong>in all cases where a pipe is used simply to signal events</strong>.  The kernel overhead of an eventfd file descriptor is much lower than that of a pipe, and only one file descriptor is required (versus the two required for a pipe).</p></blockquote>

<p>As with signal events, eventfd is much more light-weight (thus fast) compared to the pipes, it&rsquo;s just a counter in kernel after all.</p>

<blockquote><p>A key point about an eventfd file descriptor is that it can be monitored just like any other file descriptor using select(2), poll(2), or epoll(7). This means that an application can simultaneously monitor the readiness of &ldquo;traditional&rdquo; files and the readiness of other kernel mechanisms that support the eventfd interface.</p></blockquote>

<p>You won&rsquo;t wield the true power of eventfd, unless you monitor them with epoll (especially EPOLLET).</p>

<p>So, let&rsquo;s get our hands dirty with an simple worker thread pool!</p>

<h2>Worker Pool Design</h2>

<p>We adopt Producer/Consumer pattern for our worker thread pool, as it&rsquo;s the most common style of decoupling, achieving the best scalability.
By leveraging the asynchronous notification feature from the eventfd, our inter-thread communication sequence could be described as following:</p>

<p><img src="/images/worker-pool-with-eventfd/eventfd_notify.svg" alt="" /></p>

<h2>Implementation</h2>

<p>Our per-thread data structure is fairly simple, only contains 3 fields: <code>thread_id</code>, <code>rank</code> (thread index) and <code>epfd</code> which is the epoll file descriptor created by <code>main</code> function.</p>

<pre><code class="c">typedef struct thread_info {
    pthread_t thread_id;
    int rank;
    int epfd;
} thread_info_t;
</code></pre>

<h3>Consumer thread routine</h3>

<pre><code class="c">static void *consumer_routine(void *data) {
    struct thread_info *c = (struct thread_info *)data;
    struct epoll_event *events;
    int epfd = c-&gt;epfd;
    int nfds = -1;
    int i = -1;
    int ret = -1;
    uint64_t v;
    int num_done = 0;

    events = calloc(MAX_EVENTS_SIZE, sizeof(struct epoll_event));
    if (events == NULL) exit_error("calloc epoll events\n");

    for (;;) {
        nfds = epoll_wait(epfd, events, MAX_EVENTS_SIZE, 1000);
        for (i = 0; i &lt; nfds; i++) {
            if (events[i].events &amp; EPOLLIN) {
                log_debug("[consumer-%d] got event from fd-%d",
                        c-&gt;rank, events[i].data.fd);
                ret = read(events[i].data.fd, &amp;v, sizeof(v));
                if (ret &lt; 0) {
                    log_error("[consumer-%d] failed to read eventfd", c-&gt;rank);
                    continue;
                }
                close(events[i].data.fd);
                do_task();
                log_debug("[consumer-%d] tasks done: %d", c-&gt;rank, ++num_done);
            }
        }
    }
}
</code></pre>

<p>As we can see, the worker thread get the notification by simply polling <code>epoll_wait()</code> the epoll-added fd list, and <code>read()</code> the eventfd to consume it,  then <code>close()</code> to clean it.
And we can do anything sequential within the <code>do_task</code>, although it now does nothing.</p>

<p>In short: poll -> read -> close.</p>

<h4>Producer thread routine</h4>

<pre><code class="c">static void *producer_routine(void *data) {
    struct thread_info *p = (struct thread_info *)data;
    struct epoll_event event;
    int epfd = p-&gt;epfd;
    int efd = -1;
    int ret = -1;
    int interval = 1;

    log_debug("[producer-%d] issues 1 task per %d second", p-&gt;rank, interval);
    while (1) {
        efd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
        if (efd == -1) exit_error("eventfd create: %s", strerror(errno));
        event.data.fd = efd;
        event.events = EPOLLIN | EPOLLET;
        ret = epoll_ctl(epfd, EPOLL_CTL_ADD, efd, &amp;event);
        if (ret != 0) exit_error("epoll_ctl");
        ret = write(efd, &amp;(uint64_t){1}, sizeof(uint64_t));
        if (ret != 8) log_error("[producer-%d] failed to write eventfd", p-&gt;rank);
        sleep(interval);
    }
}
</code></pre>

<p>In producer routine, after creating <code>eventfd</code>, we register the event with epoll object by <code>epoll_ctl()</code>. Note that the event is set for write (EPOLLIN) and Edge-Triggered (EPOLLET).
For notification, what we need to do is just write <code>0x1</code> (any value you want) to eventfd.</p>

<p>In short: create -> register -> write.</p>

<p><em>Source code repository</em>: <a href="https://github.com/Pro-YY/eventfd_examples/">eventfd_examples</a></p>

<h2>Output &amp; Analysis</h2>

<p>The expected output is clear as:</p>

<p><img src="/images/worker-pool-with-eventfd/eventfd_worker_execution.gif" alt="" /></p>

<p>You can adjust threads number to inspect the detail, and there&rsquo;s a plethora of fun with it.</p>

<p>But now, let&rsquo;s try something hard. We&rsquo;ll <code>smoke test</code> our worker by generate a heavy instant load, instead of the former regular one. And we tweak the producer/consumer thread to 1, and watching the performance.
```c
static void <em>producer_routine_spike(void </em>data) {
    struct thread_info <em>p = (struct thread_info </em>)data;
    struct epoll_event event;
    int epfd = p->epfd;
    int efd = -1;
    int ret = -1;
    int num_task = 1000000;</p>

<pre><code>log_debug("[producer-%d] will issue %d tasks", p-&gt;rank, num_task);
for (int i = 0; i &lt; num_task; i++) {
    efd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
    if (efd == -1) exit_error("eventfd create: %s", strerror(errno));
    event.data.fd = efd;
    event.events = EPOLLIN | EPOLLET;
    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, efd, &amp;event);
    if (ret != 0) exit_error("epoll_ctl");
    ret = write(efd, &amp;(uint64_t){1}, sizeof(uint64_t));
    if (ret != 8) log_error("[producer-%d] failed to write eventfd", p-&gt;rank);
}
return (void *)0;
</code></pre>

<p>}
```</p>

<p><strong>Over 1 million?</strong> Indeed! By using the <code>ulimit</code> command below, we can increase the <code>open files</code> limit of the current shell, which is usually 1024 by default.
Note that you need to be root.
```
ulimit -n 1048576</p>

<h1>1048576 is the default maximum for open files, as <code>/proc/sys/fs/nr_open</code> shows.</h1>

<h1>To make it larger, you need to tweak kernel settings like this (which is beyond our scope)</h1>

<h1>sysctl -w fs.nr_open=10485760</h1>

<p>```
Since the info of stdout is so much that we redirect the stdout to file <em>log</em>.
<img src="/images/worker-pool-with-eventfd/eventfd_worker_execution_spike.gif" alt="" /></p>

<p>With my test VM (S2.Medium4 type on <a href="https://cloud.tencent.com/">TencentCloud</a>, which has only 2 vCPU and 4G memory, it takes less than 6.5 seconds to deal with 1 million concurrent (almost) events. And we&rsquo;ve seen the kernel-implemented counters and wait queue are quite efficient.</p>

<h2>Conclusions</h2>

<p>Multi-threaded programming model is prevailing now, while the best way of scheduling (event trigger and dispatching method) is still under discussion and sometimes even opinionated.
In this post, we&rsquo;ve implemented general-purposed worker thread pool based on an advanced message mechanism, which includes:</p>

<ol>
<li>message notification: asynchronous delivering, extremely low overhead, high performance</li>
<li>message dispatching: as a load balancer, highly scalable</li>
<li>message buffering: as message queue, with robustness</li>
</ol>


<p>All the above are fulfilled by using basic Linux kernel feature/syscall, like <code>epoll</code> and <code>eventfd</code>.
Everyone may refers to this approach when he/she designs a single-process performant (especially IO-bound) background service.</p>

<p>To sum up, taking advantage of Linux kernel capability, we are now managed to implement our high-performance message-based worker pool, which is able to deal with large throughput and of high scalability.</p>

<h2>References</h2>

<ul>
<li><a href="https://linux.die.net/man/2/eventfd">eventfd(2) - Linux Man Page</a></li>
<li><a href="https://elixir.bootlin.com/linux/latest/source/fs/eventpoll.c">eventpoll - Linux Source Code</a></li>
<li><a href="https://elixir.bootlin.com/linux/latest/source/fs/eventfd.c">eventfd - Linux Source Code</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building Linux Kernel Module]]></title>
    <link href="https://www.yangyang.cloud/blog/2018/10/23/building-linux-kernel-module/"/>
    <updated>2018-10-23T10:30:28+08:00</updated>
    <id>https://www.yangyang.cloud/blog/2018/10/23/building-linux-kernel-module</id>
    <content type="html"><![CDATA[<h2>Overview</h2>

<ul>
<li>What is Linux loadable kernel module(LKM)?</li>
</ul>


<p>A loadable kernel module (LKM) is a mechanism for adding/removing code from Linux kernel <strong>at run time</strong>.
Many of device drivers are implemented through this way, otherwise the monolithic kernel would be too large.</p>

<p>LKM communicates with user-space applications through system calls, and it can access almost all the objects/services of the kernel.
LKM can be inserted to the monolithic kernel at any time &ndash; usually at booting or running phase.</p>

<p>Writing LKM has many advantages against directly tweaking the whole kernel. For LKM can be dynamically inserted or removed at run time, we don&rsquo;t need to recompile the whole kernel nor reboot, and it&rsquo;s more shippable.</p>

<p>So, the easiest way to start kernel programming is to write a module - a piece of code that can be dynamically loaded into the kernel.</p>

<ul>
<li>How is the LKM different from an user-space application?</li>
</ul>


<p>LKM is run in kernel space, which is quite different.</p>

<p>First off, the code is always asynchronous, which means it doesn&rsquo;t execute sequentially and may be interrupted at any time. Thus programmers should always care about the concurrency as well as reentrant issues. Unlike user-space application, which has an entry-point like <code>main()</code> and then execute and exit, the LKM is more like a complicated event-driven server that internally has the ability to interact with various kernel services, and externally provides system calls as its user-space <code>api</code>.</p>

<p>Secondly, there&rsquo;s only a fixed and small stack, resource cleanup as well as utilization should always be highly considered. While as for the user-space application, the resource quota is fairly sufficient.</p>

<p>Thirdly, note that there&rsquo;s no floating-point math.</p>

<h2>Prepare Headers</h2>

<pre><code class="sh">apt search linux-headers-$(uname -r)
# get our kernel release: 4.18.0.kali2-amd64
apt install linux-headers-4.18.0.kali2-amd64
</code></pre>

<h2>Simple Module Code</h2>

<p><em>hello.c</em></p>

<pre><code class="c">#include &lt;linux/module.h&gt;

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Brooke Yang");
MODULE_DESCRIPTION("A simple Linux moadable mernel module");
MODULE_VERSION("0.1");

static char *name = "world";
module_param(name, charp, S_IRUGO);
MODULE_PARM_DESC(name, "The name to display");

static int __init hello_init(void) {
    pr_info("HELLO: Hello, %s!\n", name);
    return 0;
}

static void __exit hello_exit(void) {
    pr_info("HELLO: Bye-bye, %s!\n", name);
}

module_init(hello_init);
module_exit(hello_exit);
</code></pre>

<p><strong>pr_info</strong> is a more convenient way of debugging, comparing to the old-style <strong>printk</strong>.
<code>sh
printk(KERN_INFO ...);  
</code></p>

<p><em>Makefile</em>
```makefile
obj-m+=hello.o</p>

<p>all:
    make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modules
clean:
    make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean
```</p>

<h2>Build &amp;&amp; Install</h2>

<p>Now we can <code>make</code> our <strong>hello</strong> module and then a <em>hello.ko</em> emerged successfully.
<code>sh
root@kali:/opt/kernel-modules/hello# make
make -C /lib/modules/4.18.0-kali2-amd64/build/ M=/opt/kernel-modules/hello modules
make[1]: Entering directory '/usr/src/linux-headers-4.18.0-kali2-amd64'
  CC [M]  /opt/kernel-modules/hello/hello.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /opt/kernel-modules/hello/hello.mod.o
  LD [M]  /opt/kernel-modules/hello/hello.ko
make[1]: Leaving directory '/usr/src/linux-headers-4.18.0-kali2-amd64'
root@kali:/opt/kernel-modules/hello# ls -l
total 556
-rw-r--r-- 1 root root    566 Oct 23 09:41 hello.c
-rw-r--r-- 1 root root 272720 Oct 23 09:41 hello.ko
-rw-r--r-- 1 root root    872 Oct 23 09:41 hello.mod.c
-rw-r--r-- 1 root root 136376 Oct 23 09:41 hello.mod.o
-rw-r--r-- 1 root root 137864 Oct 23 09:41 hello.o
-rw-r--r-- 1 root root    154 Oct 23 09:38 Makefile
-rw-r--r-- 1 root root     42 Oct 23 09:41 modules.order
-rw-r--r-- 1 root root      0 Oct 23 09:41 Module.symvers
</code></p>

<p>Display module info
<code>
root@kali:/opt/kernel-modules/hello# modinfo hello.ko
filename:       /opt/kernel-modules/hello/hello.ko
version:        0.1
description:    A simple Linux moadable mernel module
author:         Brooke Yang
license:        GPL
srcversion:     440743A20C6C4688E185D30
depends:        
retpoline:      Y
name:           hello
vermagic:       4.18.0-kali2-amd64 SMP mod_unload modversions
parm:           name:The name to display (charp)
</code></p>

<pre><code>root@kali:/opt/kernel-modules/hello# insmod hello.ko
root@kali:/opt/kernel-modules/hello# rmmod hello
root@kali:/opt/kernel-modules/hello# insmod hello.ko name=Brooke
root@kali:/opt/kernel-modules/hello# rmmod hello
</code></pre>

<p>we can watch the log by <code>tail -f</code> the <em>/var/log/kern.log</em> or just <code>dmesg</code>
<code>
Oct 23 09:51:37 kali kernel: [ 2651.831228] HELLO: Hello, world!
Oct 23 09:51:44 kali kernel: [ 2658.680087] HELLO: Bye-bye, world!
Oct 23 09:51:57 kali kernel: [ 2672.409216] HELLO: Hello, Brooke!
Oct 23 09:52:02 kali kernel: [ 2677.482181] HELLO: Bye-bye, Brooke!
</code>
Done!</p>

<p>note: char parm can even be Chinese.</p>

<h2>Conclusions</h2>

<p>With this article, we managed to complete our first yet very simple Linux loadable kernel module(LKM).</p>

<p>We&rsquo;ve got a broad view of how the LKMs work. And we should configure our own kernel modules, build and insert/remove them at runtime, and define/pass custom parameters to them.</p>

<h2>References</h2>

<ul>
<li><a href="http://derekmolloy.ie/writing-a-linux-kernel-module-part-1-introduction/">writing a linux kernel module part 1 introduction</a></li>
<li><a href="https://qnaplus.com/how-to-compile-linux-kernel-module/">how to compile linux kernel modul</a></li>
<li><a href="https://qnaplus.com/linux-kernel-programming-basics-create-loadable-kernel-module/">linux kernel programming basics create loadable kernel module</a></li>
<li><a href="https://www.linuxvoice.com/be-a-kernel-hacker/">be a kernel hacker</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiling Kernel With Kali Linux]]></title>
    <link href="https://www.yangyang.cloud/blog/2018/10/22/compiling-kernel-with-kali-linux/"/>
    <updated>2018-10-22T09:57:10+08:00</updated>
    <id>https://www.yangyang.cloud/blog/2018/10/22/compiling-kernel-with-kali-linux</id>
    <content type="html"><![CDATA[<p>With the instructions in <a href="https://docs.kali.org/development/recompiling-the-kali-linux-kernel">Recompiling the Kali Linux Kernel</a>, we can recompile the whole linux kernel of our kali linux.</p>

<h2>Install Dependencies</h2>

<p>We need to start by installing several build dependency packages, some of them may have already been in installed.
<code>
apt install build-essential libncurses5-dev fakeroot bison libssl-dev libelf-dev
</code></p>

<h2>Download the Kernel Source</h2>

<p>For my system, the kernel version is 4.18, which will be used in following example. Of course, the workflow of other version is just the same.
<code>
apt install linux-source-4.18
[...]
ls /usr/src
linux-config-4.18 linux-patch-4.18-rt.patch.xz linux-source-4.18.tar.xz
</code>
Then we get the compressed archive of the kernel sources, and we&rsquo;ll extract these files in our working directory, (no special permission need for compiling the kernel). In our example, we use <em>/opt/kernel</em>, and the <em>~/kernel</em> is also an appropriate place.</p>

<pre><code>mkdir /opt/kernel; cd /opt/kernel
tar -xaf /usr/src/linux-source-4.18.tar.xz
</code></pre>

<p>Optionally, we may also apply the <em>rt</em> patch, which is for real-time os features.
<code>
cd /opt/kernel/linux-source-4.18
xzcat /usr/src/linux-patch-4.18-rt.patch.xz | patch -p1
</code></p>

<h2>Configure the Kernel</h2>

<p>When building a more recent version of kernel (possibly with an specific patch), the configuration should at first be kept as close as possible to the current running kernel, shown by <strong>uname -r</strong>. It is sufficient to just copy the currently-used kernel config to the source directory.
<code>
cd /opt/kernel/linux-source-4.18
cp /boot/config-4.18.0-kali2-amd64 .config
</code></p>

<p>If you need to make some changes or decide to reconfigure all things from scratch, just call <strong>make menuconfig</strong> command and inspect all the details.
Note: we can tweak a lot in this phase.</p>

<h2>Write Some Code</h2>

<p>Add one line of code for test(fun), in file <em>init/main.c</em>, <strong>start_kernel</strong> function
<code>
    pr_notice("Brookes's customized kernel starting: %s %d\n", __FUNCTION__, __LINE__);
    pr_notice("%s", linux_banner);
</code></p>

<h2>Build the Kernel</h2>

<p>Once configured, we can <strong>make</strong> the kernel. Rather than invoking <strong>make deb-pkg</strong> as the official doc suggested, we use <strong>make bindeb-pkg</strong> here, which will not generate Debian source package, or invoke <strong>make clean</strong>.
<code>
time make -j4 bindeb-pkg LOCALVERSION=-custom KDEB_PKGVERSION=$(make kernelversion)-$(date +%Y%m%d)
</code>
After a while, we get following package in the parent directory
<code>
linux-headers-4.18.10-custom_4.18.10-20181021_amd64.deb   # headers
linux-image-4.18.10-custom_4.18.10-20181021_amd64.deb     # kernel image
linux-image-4.18.10-custom-dbg_4.18.10-20181021_amd64.deb # kernel image with debugging symbols
linux-libc-dev_4.18.10-20181021_amd64.deb                 # headers of user-space library
</code></p>

<h3>Trouble Shooting</h3>

<pre><code>No rule to make target 'debian/certs/test-signing-certs.pem', needed by 'certs/x509_certificate_list'. Stop
</code></pre>

<p>Solve: comment/delete the corresponding config line.</p>

<h2>Install/Remove the Kernel</h2>

<pre><code>dpkg -i ../linux-image-4.18.10-custom_4.18.10-custom_4.18.10-20181021_amd64.deb
reboot
</code></pre>

<p>Once booted, we can use <strong>dmesg</strong> to verify our printk message.
Removing kernel can also be done with dpkg.
<code>
dpkg -r linux-image-4.18.10-custom
</code></p>
]]></content>
  </entry>
  
</feed>
